<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Iterative Solvers · MatrixEquations.jl</title><meta name="title" content="Iterative Solvers · MatrixEquations.jl"/><meta property="og:title" content="Iterative Solvers · MatrixEquations.jl"/><meta property="twitter:title" content="Iterative Solvers · MatrixEquations.jl"/><meta name="description" content="Documentation for MatrixEquations.jl."/><meta property="og:description" content="Documentation for MatrixEquations.jl."/><meta property="twitter:description" content="Documentation for MatrixEquations.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MatrixEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lyapunov.html">Lyapunov Matrix Equation Solvers</a></li><li><a class="tocitem" href="plyapunov.html">Positive-definite Lyapunov Matrix Equation Solvers</a></li><li><a class="tocitem" href="riccati.html">Riccati Matrix Equation Solvers</a></li><li><a class="tocitem" href="sylvester.html">Sylvester Matrix Equation Solvers</a></li><li><a class="tocitem" href="sylvkr.html">Matrix Equation Solvers using Kronecker-product Expansions</a></li><li><a class="tocitem" href="condest.html">Norm, Condition Number and Separation Estimations</a></li><li><a class="tocitem" href="meoperators.html">Linear Operators Related to Matrix Equation Solvers</a></li><li class="is-active"><a class="tocitem" href="iterative.html">Iterative Solvers</a><ul class="internal"><li><a class="tocitem" href="#Conjugate-Gradient-based-Solution-of-Linear-Equations"><span>Conjugate Gradient based Solution of Linear Equations</span></a></li><li><a class="tocitem" href="#Continuous-time-Lyapunov-and-Lyapunov-like-Matrix-Equations"><span>Continuous-time Lyapunov and Lyapunov-like Matrix Equations</span></a></li><li><a class="tocitem" href="#Sylvester-and-Sylvester-like-Matrix-Equations"><span>Sylvester and Sylvester-like Matrix Equations</span></a></li></ul></li></ul></li><li><span class="tocitem">Internal</span><ul><li><a class="tocitem" href="lapackutil.html">Lapack Utilities</a></li><li><a class="tocitem" href="meutil.html">Matrix Equations Utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="iterative.html">Iterative Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="iterative.html">Iterative Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixEquations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/master/docs/src/iterative.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Iterative-Solvers"><a class="docs-heading-anchor" href="#Iterative-Solvers">Iterative Solvers</a><a id="Iterative-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Solvers" title="Permalink"></a></h1><h2 id="Conjugate-Gradient-based-Solution-of-Linear-Equations"><a class="docs-heading-anchor" href="#Conjugate-Gradient-based-Solution-of-Linear-Equations">Conjugate Gradient based Solution of Linear Equations</a><a id="Conjugate-Gradient-based-Solution-of-Linear-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Conjugate-Gradient-based-Solution-of-Linear-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.cgls" href="#MatrixEquations.cgls"><code>MatrixEquations.cgls</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> cgls(A, b; shift, abstol, reltol, maxiter, x0) -&gt; (x, info)</code></pre><p>Solve <code>Ax = b</code> or minimize <code>norm(Ax-b)</code> using <code>CGLS</code>, the conjugate gradient method for unsymmetric linear equations and least squares problems.  <code>A</code> can be specified either as a rectangular matrix or as a linear operator, as defined in the <code>LinearMaps</code> package.   It is desirable that <code>eltype(A) == eltype(b)</code>, otherwise errors may result or additional allocations may occur in operator-vector products. </p><p>The keyword argument <code>shift</code> specifies a regularization parameter as <code>shift = s</code>. If <code>s = 0</code> (default), then <code>CGLS</code> is Hestenes and Stiefel&#39;s specialized form of the conjugate-gradient method for least-squares problems. If <code>s ≠ 0</code>, the system <code>(A&#39;*A + s*I)*b = A&#39;*b</code> is solved. </p><p>An absolute tolerance <code>abstol</code> and a relative tolerance <code>reltol</code> can be specified for stopping the iterative process (default: <code>abstol = 0</code>, <code>reltol = 1.e-6</code>).</p><p>The maximum number of iterations can be specified using <code>maxiter</code> (default: <code>maxiter = max(size(A),20)</code>).</p><p>An initial guess for the solution can be specified using the keyword argument vector <code>x0</code> (default: <code>x0 = missing</code>). </p><p>The resulting named tuple <code>info</code> contains <code>(flag, resNE, iter)</code>, with convergence related information, as follows: </p><pre><code class="nohighlight hljs"> `info.flag`  - convergence flag with values:  
                1, if convergence occured; 
                2, if the maximum number of iterations has been reached without convergence;
                3, if the matrix `A&#39;*A + s*I` seems to be singular or indefinite;
                4, if instability seems likely meaning `(A&#39;*A + s*I)` indefinite and `norm(x)` decreased;  

 `info.resNE` - the relative residual for the normal equations `norm(A&#39;*b - (A&#39;*A + s*I)*x)/norm(A&#39;*b)`;  

 `info.iter`  - the iteration number at which `x` was computed.</code></pre><p>This function is a translation of the MATLAB implementation of <code>CGLS</code>, the conjugate gradient method for nonsymmetric linear equations and least squares problems <a href="https://web.stanford.edu/group/SOL/software/cgls/"><code>https://web.stanford.edu/group/SOL/software/cgls/</code></a>.  The author of the code is Michael Saunders, with contributions from Per Christian Hansen, Folkert Bleichrodt and Christopher Fougner.    </p><p><em>Note:</em>  Two alternative solvers <code>lsqr</code> and <code>lsmr</code>, available in the <a href="https://github.com/JuliaLinearAlgebra/IterativeSolvers.jl"><code>IterativeSolvers</code></a> package, can also be employed.  For example, the following call to <code>lsqr</code> can be alternatively used:</p><pre><code class="nohighlight hljs">  using IterativeSolvers
  lsqr(A, b; kwargs...) -&gt; x[, history]</code></pre><p>where <code>kwargs</code> contains solver-specific keyword arguments. A similar call to  <code>lsmr</code> can be used.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1154-L1194">source</a></section></article><h2 id="Continuous-time-Lyapunov-and-Lyapunov-like-Matrix-Equations"><a class="docs-heading-anchor" href="#Continuous-time-Lyapunov-and-Lyapunov-like-Matrix-Equations">Continuous-time Lyapunov and Lyapunov-like Matrix Equations</a><a id="Continuous-time-Lyapunov-and-Lyapunov-like-Matrix-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-time-Lyapunov-and-Lyapunov-like-Matrix-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.lyapci" href="#MatrixEquations.lyapci"><code>MatrixEquations.lyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyapci(A, C; abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute for a square <code>A</code> and a hermitian/symmetric <code>C</code> a solution <code>X</code> of the continuous Lyapunov matrix equation</p><pre><code class="nohighlight hljs">            A*X + X*A&#39; + C = 0.</code></pre><p>A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1-L12">source</a></section><section><div><pre><code class="language-julia hljs">lyapci(A, E, C; abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute <code>X</code>, the solution of the generalized continuous Lyapunov equation</p><pre><code class="nohighlight hljs">AXE&#39; + EXA&#39; + C = 0,</code></pre><p>where <code>A</code> and <code>E</code> are square real or complex matrices and <code>C</code> is a square matrix. A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L34-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.plyapci" href="#MatrixEquations.plyapci"><code>MatrixEquations.plyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plyapci(A, E, B; cyclic, abstol, reltol, maxiter, nshifts, shifts, loginf) -&gt; (U, info)
plyapci(A, B; cyclic, abstol, reltol, maxiter, nshifts, shifts, loginf) -&gt; (U, info)</code></pre><p>Compute a low-rank factor <code>U</code> of the solution <code>X = UU&#39;</code> of the generalized continuous Lyapunov equation</p><pre><code class="nohighlight hljs">  AXE&#39; + EXA&#39; + BB&#39; = 0,</code></pre><p>where <code>A</code> and <code>E</code> are square real matrices and <code>B</code> is a real matrix with the same number of rows as <code>A</code>. The pencil <code>A - λE</code> must have only eigenvalues with negative real parts. <code>E = I</code> is assumed in the second call. </p><p>The named tuple <code>info</code> contains information related to the execution of the LR-ADI algorithm as follows: <code>info.niter</code> contains the number of performed iterations;  <code>info.res_fact</code> contains the norm of the residual factor;  <code>info.res</code> contains, if <code>loginf = true</code>, the vector of normalized residual norms (normalized with respect to the norm of the initial approximation); <code>info.rc</code> contains, if <code>loginf = true</code>, the vector of norms of relative changes in building the solution; <code>info.used_shift</code> contains the vector of used shifts.</p><p>The keyword argument <code>abstol</code> (default: <code>abstol = 1e-12</code>) is the tolerance used for convergence test on the normalized residuals, while the keyword argument <code>reltol</code> (default: <code>reltol = 0</code>) is the tolerance for the relative changes of the solution.  The keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 100</code>). The keyword argument <code>nshifts</code> specifies the desired number of shifts to be used in an iteration cycle (default: <code>nshifts = 6</code>).  The keyword argument <code>shifts</code> can be used to provide a pre-calculated set of complex conjugated shifts to be used to start the iterations (default: <code>shifts = missing</code>). With the keyword argument <code>loginf = true</code>, the normalized residual values and the norms of increments of the solution can be saved as outputs in the resulting info structure (default: <code>loginf = false</code>). </p><p>The low-rank ADI (LR-ADI) method with enhancements proposed in [1] is implemented, based on MATLAB  codes of the free software described in [2]. If <code>cyclic = true</code>, the cyclic low-rank method of [3] is used, with the pre-calculated shifts provided in the keyword argument <code>shifts</code>. </p><p><em>References</em></p><p>[1] P. Kürschner. Efficient Low-Rank Solution of Large-Scale Matrix Equations.      Dissertation, Otto-von-Guericke-Universität, Magdeburg, Germany, 2016. Shaker Verlag,</p><p>[2] P. Benner, M. Köhler, and J. Saak. “Matrix Equations, Sparse Solvers: M-M.E.S.S.-2.0.1—     Philosophy, Features, and Application for (Parametric) Model Order Reduction.”      In Model Reduction of Complex Dynamical Systems, Eds. P. Benner et.al., 171:369–92, Springer, 2021.</p><p>[3] T. Penzl, A cyclic low-rank Smith method for large sparse Lyapunov equations,      SIAM J. Sci. Comput. 21 (4) (1999) 1401–1418.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L69-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.lyapdi" href="#MatrixEquations.lyapdi"><code>MatrixEquations.lyapdi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyapdi(A, C; abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute for a square <code>A</code> and a hermitian/symmetric <code>C</code> a solution <code>X</code> of the discrete Lyapunov matrix equation</p><pre><code class="nohighlight hljs">            AXA&#39; - X + C = 0.</code></pre><p>A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L826-L837">source</a></section><section><div><pre><code class="language-julia hljs">lyapdi(A, E, C; abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute <code>X</code>, the solution of the generalized discrete Lyapunov equation</p><pre><code class="nohighlight hljs">AXA&#39; - EXE&#39; + C = 0,</code></pre><p>where <code>A</code> and <code>E</code> are square real or complex matrices and <code>C</code> is a square matrix. A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L858-L870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.plyapdi" href="#MatrixEquations.plyapdi"><code>MatrixEquations.plyapdi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plyapdi(A, E, B; cyclic, abstol, reltol, maxiter, nshifts, shifts, loginf) -&gt; (U, info)
plyapdi(A, B; cyclic, abstol, reltol, maxiter, nshifts, shifts, loginf) -&gt; (U, info)</code></pre><p>Compute a low-rank factor <code>U</code> of the solution <code>X = UU&#39;</code> of the generalized discrete Lyapunov equation</p><pre><code class="nohighlight hljs">  AXA&#39; - EXE&#39; + BB&#39; = 0,</code></pre><p>where <code>A</code> and <code>E</code> are square real matrices and <code>B</code> is a real matrix with the same number of rows as <code>A</code>. The pencil <code>A - λE</code> must have only eigenvalues with moduli less than one. <code>E = I</code> is assumed in the second call. </p><p>The named tuple <code>info</code> contains information related to the execution of the LR-ADI algorithm as follows: <code>info.niter</code> contains the number of performed iterations;  <code>info.res_fact</code> contains the norm of the residual factor;  <code>info.res</code> contains, if <code>loginf = true</code>, the vector of normalized residual norms (normalized with respect to the norm of the initial approximation); <code>info.rc</code> contains, if <code>loginf = true</code>, the vector of norms of relative changes in building the solution; <code>info.used_shift</code> contains the vector of used shifts.</p><p>The keyword argument <code>abstol</code> (default: <code>abstol = 1e-12</code>) is the tolerance used for convergence test on the normalized residuals, while the keyword argument <code>reltol</code> (default: <code>reltol = 0</code>) is the tolerance for the relative changes of the solution.  The keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 100</code>). The keyword argument <code>nshifts</code> specifies the desired number of shifts to be used in an iteration cycle (default: <code>nshifts = 6</code>).  The keyword argument <code>shifts</code> can be used to provide a pre-calculated set of complex conjugated shifts to be used to start the iterations (default: <code>shifts = missing</code>). With the keyword argument <code>loginf = true</code>, the normalized residual values and the norms of increments of the solution can be saved as outputs in the resulting info structure (default: <code>loginf = false</code>). </p><p>The low-rank ADI (LR-ADI) method with enhancements proposed in [1] is adapted to the discrete case,  inspired by the MATLAB codes of the free software described in [2]. If <code>cyclic = true</code>, the cyclic low-rank method of [3] is adapted, with the pre-calculated shifts provided in the keyword argument <code>shifts</code>. </p><p><em>References</em></p><p>[1] P. Kürschner. Efficient Low-Rank Solution of Large-Scale Matrix Equations.      Dissertation, Otto-von-Guericke-Universität, Magdeburg, Germany, 2016. Shaker Verlag,</p><p>[2] P. Benner, M. Köhler, and J. Saak. “Matrix Equations, Sparse Solvers: M-M.E.S.S.-2.0.1—     Philosophy, Features, and Application for (Parametric) Model Order Reduction.”      In Model Reduction of Complex Dynamical Systems, Eds. P. Benner et.al., 171:369–92, Springer, 2021.</p><p>[3] T. Penzl, A cyclic low-rank Smith method for large sparse Lyapunov equations,      SIAM J. Sci. Comput. 21 (4) (1999) 1401–1418.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L494-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.tlyapci" href="#MatrixEquations.tlyapci"><code>MatrixEquations.tlyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tlyapci(A, C, isig = +1; adj = false, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute a solution <code>X</code> of the continuous T-Lyapunov matrix equation</p><pre><code class="nohighlight hljs">            A*X +isig*transpose(X)*transpose(A) = C   if adj = false,</code></pre><p>or</p><pre><code class="nohighlight hljs">            A*transpose(X) + isig*X*transpose(A) = C   if adj = true,</code></pre><p>where for <code>isig = 1</code>, <code>C</code> is a symmetric matrix and for <code>isig = -1</code>, <code>C</code> is a skew-symmetric matrix.                     </p><p>For a matrix <code>A</code>, a least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined T-Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1026-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.hlyapci" href="#MatrixEquations.hlyapci"><code>MatrixEquations.hlyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hlyapci(A, C, isig = +1; adj = false, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute a solution <code>X</code> of the continuous H-Lyapunov matrix equation</p><pre><code class="nohighlight hljs">            A*X + isig*X&#39;*A&#39; = C   if adj = false,</code></pre><p>or</p><pre><code class="nohighlight hljs">            A*X&#39; + isig*X*A&#39; = C   if adj = true,</code></pre><p>where for <code>isig = 1</code>, <code>C</code> is a hermitian matrix and for <code>isig = -1</code>, <code>C</code> is a skew-hermitian matrix.                     </p><p>For a matrix <code>A</code>, a least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined T-Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution.  The keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1061-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.tulyapci" href="#MatrixEquations.tulyapci"><code>MatrixEquations.tulyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tulyapci(U, Q; adj = false, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute for an upper triangular <code>U</code> and a symmetric <code>Q</code> an upper triangular solution <code>X</code> of the continuous T-Lyapunov matrix equation</p><pre><code class="nohighlight hljs">  transpose(U)*X + transpose(X)*U = Q   if adj = false,</code></pre><p>or </p><pre><code class="nohighlight hljs">  U*transpose(X) + X*transpose(U) = Q   if adj = true.</code></pre><p>For a <code>n×n</code> upper triangular matrix <code>U</code>, a least-squares upper-triangular solution <code>X</code> is determined using a conjugate-gradient based iterative method applied  to a suitably defined T-Lyapunov linear operator <code>L:X -&gt; Y</code>, which maps upper triangular matrices <code>X</code> into upper triangular matrices <code>Y</code>, and the associated matrix <code>M = Matrix(L)</code> is <span>$n(n+1)/2 \times n(n+1)/2$</span>.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution.  The keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1098-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.hulyapci" href="#MatrixEquations.hulyapci"><code>MatrixEquations.hulyapci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hulyapci(U, Q; adj = false, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute for an upper triangular <code>U</code> and a hermitian <code>Q</code> an upper triangular solution <code>X</code> of the continuous H-Lyapunov matrix equation</p><pre><code class="nohighlight hljs">            U&#39;*X + X&#39;*U = Q   if adj = false,</code></pre><p>or</p><pre><code class="nohighlight hljs">            U*X&#39; + X*U&#39; = Q    if adj = true.</code></pre><p>For a <code>n×n</code> upper triangular matrix <code>U</code>, a least-squares upper-triangular solution <code>X</code> is determined using a conjugate-gradient based iterative method applied  to a suitably defined T-Lyapunov linear operator <code>L:X -&gt; Y</code>, which maps upper triangular matrices <code>X</code> into upper triangular matrices <code>Y</code>, and the associated matrix <code>M = Matrix(L)</code> is <span>$n(n+1)/2 \times n(n+1)/2$</span>.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution.  The keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L1126-L1142">source</a></section></article><h2 id="Sylvester-and-Sylvester-like-Matrix-Equations"><a class="docs-heading-anchor" href="#Sylvester-and-Sylvester-like-Matrix-Equations">Sylvester and Sylvester-like Matrix Equations</a><a id="Sylvester-and-Sylvester-like-Matrix-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Sylvester-and-Sylvester-like-Matrix-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.sylvci" href="#MatrixEquations.sylvci"><code>MatrixEquations.sylvci</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = sylvci(A,B,C)</code></pre><p>Solve the continuous Sylvester matrix equation</p><pre><code class="nohighlight hljs">            AX + XB = C ,</code></pre><p>where <code>A</code> and <code>B</code> are square matrices. </p><p>A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L896-L909">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.sylvdi" href="#MatrixEquations.sylvdi"><code>MatrixEquations.sylvdi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = sylvdi(A,B,C)</code></pre><p>Solve the discrete Sylvester matrix equation</p><pre><code class="nohighlight hljs">            AXB + X = C ,</code></pre><p>where <code>A</code> and <code>B</code> are square matrices. </p><p>A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L917-L931">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.gsylvi" href="#MatrixEquations.gsylvi"><code>MatrixEquations.gsylvi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = gsylvi(A,B,C,D,E)</code></pre><p>Solve the generalized Sylvester matrix equation</p><pre><code class="nohighlight hljs">AXB + CXD = E ,</code></pre><p>where <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> are square matrices. </p><p>A least-squares solution <code>X</code> is determined using a conjugate gradient based iterative method applied  to a suitably defined Lyapunov linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = C</code> or <code>norm(L(X) - C)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L939-L952">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.gtsylvi" href="#MatrixEquations.gtsylvi"><code>MatrixEquations.gtsylvi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> gtsylvi(A, B, C, D, E; mx, nx, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute a solution <code>X</code> of the generalized T-Sylvester matrix equation</p><pre><code class="nohighlight hljs">  ∑ A_i*X*B_i + ∑ C_j*transpose(X)*D_j = E,</code></pre><p>where <code>A_i</code> and <code>C_j</code> are matrices having the same row dimension equal to the row dimension of <code>E</code> and  <code>B_i</code> and <code>D_j</code> are matrices having the same column dimension equal to the column dimension of <code>E</code>.  <code>A_i</code> and <code>B_i</code> are contained in the <code>k</code>-vectors of matrices <code>A</code> and <code>B</code>, respectively, and  <code>C_j</code> and <code>D_j</code> are contained in the <code>l</code>-vectors of matrices <code>C</code> and <code>D</code>, respectively.  Any of the component matrices can be given as an <code>UniformScaling</code>.  The keyword parameters <code>mx</code> and <code>nx</code> can be used to specify the row and column dimensions of <code>X</code>,  if they cannot be inferred from the data.</p><p>A least-squares solution <code>X</code> is determined using a conjugate-gradient based iterative method applied  to a suitably defined T-Sylvester linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = E</code> or <code>norm(L(X) - E)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p><p><em>Note:</em> For the derivation of the adjoint equation see reference [1], which also served as motivation to implement a general linear matrix equation solver in Julia.  </p><p>[1] Uhlig, F., Xu, A.B. Iterative optimal solutions of linear matrix equations for hyperspectral and multispectral image fusing. Calcolo 60, 26 (2023).      <a href="https://doi.org/10.1007/s10092-023-00514-8">https://doi.org/10.1007/s10092-023-00514-8</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L964-L988">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.ghsylvi" href="#MatrixEquations.ghsylvi"><code>MatrixEquations.ghsylvi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> ghsylvi(A, B, C, D, E; mx, nx, abstol, reltol, maxiter) -&gt; (X,info)</code></pre><p>Compute a solution <code>X</code> of the generalized H-Sylvester matrix equation</p><pre><code class="nohighlight hljs">  ∑ A_i*X*B_i + ∑ C_j*X&#39;*D_j = E,</code></pre><p>where <code>A_i</code> and <code>C_j</code> are matrices having the same row dimension equal to the row dimension of <code>E</code> and  <code>B_i</code> and <code>D_j</code> are matrices having the same column dimension equal to the column dimension of <code>E</code>.  <code>A_i</code> and <code>B_i</code> are contained in the <code>k</code>-vectors of matrices <code>A</code> and <code>B</code>, respectively, and  <code>C_j</code> and <code>D_j</code> are contained in the <code>l</code>-vectors of matrices <code>C</code> and <code>D</code>, respectively.  Any of the component matrices can be given as an <code>UniformScaling</code>.  The keyword parameters <code>mx</code> and <code>nx</code> can be used to specify the row and column dimensions of <code>X</code>,  if they cannot be inferred from the data.</p><p>A least-squares solution <code>X</code> is determined using a conjugate-gradient based iterative method applied  to a suitably defined T-Sylvester linear operator <code>L:X -&gt; Y</code> such that <code>L(X) = E</code> or <code>norm(L(X) - E)</code> is minimized.  The keyword arguments <code>abstol</code> (default: <code>abstol = 0</code>) and <code>reltol</code> (default: <code>reltol = sqrt(eps())</code>) can be used to provide the desired tolerance for the accuracy of the computed solution and  the keyword argument <code>maxiter</code> can be used to set the maximum number of iterations (default: <code>maxiter = 1000</code>). </p><p><em>Note:</em> For the derivation of the adjoint equation see reference [1], which also served as motivation to implement a general linear matrix equation solver in Julia.  </p><p>[1] Uhlig, F., Xu, A.B. Iterative optimal solutions of linear matrix equations for hyperspectral and multispectral image fusing. Calcolo 60, 26 (2023).      <a href="https://doi.org/10.1007/s10092-023-00514-8">https://doi.org/10.1007/s10092-023-00514-8</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/dc88b9b3c6dfcdaaee7bc92725335c5a408ad671/src/iterative_methods.jl#L995-L1019">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="meoperators.html">« Linear Operators Related to Matrix Equation Solvers</a><a class="docs-footer-nextpage" href="lapackutil.html">Lapack Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 26 June 2025 12:37">Thursday 26 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
