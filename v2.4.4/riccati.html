<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Riccati Matrix Equation Solvers · MatrixEquations.jl</title><meta name="title" content="Riccati Matrix Equation Solvers · MatrixEquations.jl"/><meta property="og:title" content="Riccati Matrix Equation Solvers · MatrixEquations.jl"/><meta property="twitter:title" content="Riccati Matrix Equation Solvers · MatrixEquations.jl"/><meta name="description" content="Documentation for MatrixEquations.jl."/><meta property="og:description" content="Documentation for MatrixEquations.jl."/><meta property="twitter:description" content="Documentation for MatrixEquations.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MatrixEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lyapunov.html">Lyapunov Matrix Equation Solvers</a></li><li><a class="tocitem" href="plyapunov.html">Positive-definite Lyapunov Matrix Equation Solvers</a></li><li class="is-active"><a class="tocitem" href="riccati.html">Riccati Matrix Equation Solvers</a><ul class="internal"><li><a class="tocitem" href="#Standard-Riccati-Matrix-Equations"><span>Standard Riccati Matrix Equations</span></a></li><li><a class="tocitem" href="#Generalized-Riccati-Matrix-Equations"><span>Generalized Riccati Matrix Equations</span></a></li></ul></li><li><a class="tocitem" href="sylvester.html">Sylvester Matrix Equation Solvers</a></li><li><a class="tocitem" href="sylvkr.html">Matrix Equation Solvers using Kronecker-product Expansions</a></li><li><a class="tocitem" href="condest.html">Norm, Condition Number and Separation Estimations</a></li><li><a class="tocitem" href="meoperators.html">Linear Operators Related to Matrix Equation Solvers</a></li><li><a class="tocitem" href="iterative.html">Iterative Solvers</a></li></ul></li><li><span class="tocitem">Internal</span><ul><li><a class="tocitem" href="lapackutil.html">Lapack Utilities</a></li><li><a class="tocitem" href="meutil.html">Matrix Equations Utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="riccati.html">Riccati Matrix Equation Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="riccati.html">Riccati Matrix Equation Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixEquations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/master/docs/src/riccati.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Riccati-Matrix-Equation-Solvers"><a class="docs-heading-anchor" href="#Riccati-Matrix-Equation-Solvers">Riccati Matrix Equation Solvers</a><a id="Riccati-Matrix-Equation-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Riccati-Matrix-Equation-Solvers" title="Permalink"></a></h1><h2 id="Standard-Riccati-Matrix-Equations"><a class="docs-heading-anchor" href="#Standard-Riccati-Matrix-Equations">Standard Riccati Matrix Equations</a><a id="Standard-Riccati-Matrix-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Riccati-Matrix-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.arec" href="#MatrixEquations.arec"><code>MatrixEquations.arec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arec(A, G, Q = 0; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs"> A&#39;X + XA - XGX + Q = 0,</code></pre><p>where <code>G</code> and <code>Q</code> are hermitian/symmetric matrices or uniform scaling operators. Scalar-valued <code>G</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>G*I</code> and <code>Q*I</code>. The Schur method of [1] is used. </p><p>To enhance the accuracy of computations, a block scaling of matrices <code>G</code> and <code>Q</code> is performed, if   the default setting <code>scaling = &#39;B&#39;</code> is used. This scaling is however performed only if <code>norm(Q) &gt; norm(G)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, experimental structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.  Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) eigenvalues of <code>A-GX</code>.</p><p><code>Z = [U; V]</code> is an orthogonal basis for the stable/anti-stable deflating subspace such that <code>X = Sx*(V/U)*Sxi</code>,  where <code>Sx</code> and <code>Sxi</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code> and <code>scalinfo.Sxi</code>, respectively.</p><p><em>Note:</em> To solve the continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs"> A&#39;X + XA - XBR^(-1)B&#39;X + Q = 0,</code></pre><p>with <code>R</code> a hermitian/symmetric matrix and <code>B</code> a compatible size matrix, <code>G = BR^(-1)B&#39;</code> must be provided.  This approach is not numerically suited when <code>R</code> is ill-conditioned and/or <code>B</code> has large norm.  </p><p><code>Reference:</code></p><p>[1] Laub, A.J., A Schur Method for Solving Algebraic Riccati equations.     IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; A = [-6. -2. 1.; 5. 1. -1; -4. -2. -1.]
3×3 Array{Float64,2}:
 -6.0  -2.0   1.0
  5.0   1.0  -1.0
 -4.0  -2.0  -1.0

julia&gt; G = [1. 0. 0.; 0. 5. 0.; 0. 0. 10.]
3×3 Array{Float64,2}:
 1.0  0.0   0.0
 0.0  5.0   0.0
 0.0  0.0  10.0

julia&gt; X, CLSEIG = arec(A,G,2I);

julia&gt; X
3×3 Array{Float64,2}:
  0.459589   0.333603   -0.144406
  0.333603   0.65916    -0.0999216
 -0.144406  -0.0999216   0.340483

julia&gt; A&#39;*X+X*A-X*G*X+2I
3×3 Array{Float64,2}:
  2.22045e-16  4.44089e-16  -1.77636e-15
  4.44089e-16  6.66134e-16   1.11022e-16
 -1.77636e-15  1.11022e-16  -1.33227e-15

julia&gt; CLSEIG
3-element Array{Complex{Float64},1}:
 -4.411547592296008 + 2.4222082620381102im
 -4.411547592296008 - 2.4222082620381102im
 -4.337128244724371 + 0.0im

julia&gt; eigvals(A-G*X)
3-element Array{Complex{Float64},1}:
 -4.4115475922960075 - 2.4222082620381076im
 -4.4115475922960075 + 2.4222082620381076im
  -4.337128244724374 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L1-L86">source</a></section><section><div><pre><code class="language-julia hljs">arec(A, B, R, Q, S; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, orth = false, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs"> A&#39;X + XA - (XB+S)R^(-1)(B&#39;X+S&#39;) + Q = 0,</code></pre><p>where <code>R</code> and <code>Q</code> are hermitian/symmetric matrices or uniform scaling operators such that <code>R</code> is nonsingular. Scalar-valued <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>R*I</code> and <code>Q*I</code>. <code>S</code>, if not specified, is set to <code>S = zeros(size(B))</code>. The Schur method of [1] is used. </p><p>To enhance the accuracy of computations, a block scaling of matrices <code>R</code>, <code>Q</code>  and <code>S</code> is performed, if   the default setting <code>scaling = &#39;B&#39;</code> is used. This scaling is however performed only if <code>norm(Q) &gt; norm(B)^2/norm(R)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Experimental structure preserving scalings can be performed using the options <code>scaling = &#39;D&#39;</code>  or <code>scaling = &#39;T&#39;</code>. Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) eigenvalues of <code>A-BF</code>.</p><p><code>F</code> is the stabilizing or anti-stabilizing gain matrix <code>F = R^(-1)(B&#39;X+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is a basis for the relevant stable/anti-stable deflating subspace  such that <code>X = Sx*(V/U)*Sxi</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively. An orthogonal basis <code>Z</code> can be determined, with an increased computational cost, by setting <code>orth = true</code>.</p><p><code>Reference:</code></p><p>[1] Laub, A.J., A Schur Method for Solving Algebraic Riccati equations.     IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; A = [-6. -2. 1.; 5. 1. -1; -4. -2. -1.]
3×3 Array{Float64,2}:
 -6.0  -2.0   1.0
  5.0   1.0  -1.0
 -4.0  -2.0  -1.0

julia&gt; B = [1. 2.; 2. 0.; 0. 1.]
3×2 Array{Float64,2}:
 1.0  2.0
 2.0  0.0
 0.0  1.0

julia&gt; R = [1. 0.; 0. 5.]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  5.0

julia&gt; X, CLSEIG, F = arec(A,B,R,2I);

julia&gt; X
3×3 Array{Float64,2}:
  0.522588   0.303007  -0.327227
  0.303007   0.650895  -0.132608
 -0.327227  -0.132608   0.629825

julia&gt; A&#39;*X+X*A-X*B*inv(R)*B&#39;*X+2I
3×3 Array{Float64,2}:
 -2.66454e-15  -1.55431e-15   8.88178e-16
 -1.55431e-15   2.22045e-15  -2.9976e-15
  9.99201e-16  -2.9976e-15    4.44089e-16

julia&gt; CLSEIG
3-element Array{Complex{Float64},1}:
   -4.37703628399912 + 2.8107164873731247im
   -4.37703628399912 - 2.8107164873731247im
 -1.8663764577096091 + 0.0im

julia&gt; eigvals(A-B*F)
3-element Array{Complex{Float64},1}:
  -4.377036283999118 - 2.8107164873731234im
  -4.377036283999118 + 2.8107164873731234im
 -1.8663764577096063 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L150-L239">source</a></section><section><div><pre><code class="language-julia hljs">arec(A, B, G, R, Q, S; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, orth = false, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Computes <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs"> A&#39;X + XA - XGX - (XB+S)R^(-1)(B&#39;X+S&#39;) + Q = 0,</code></pre><p>where <code>G</code>, <code>R</code> and <code>Q</code> are hermitian/symmetric matrices or uniform scaling operators such that <code>R</code> is nonsingular. Scalar-valued <code>G</code>, <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>G*I</code>, <code>R*I</code> and <code>Q*I</code>. <code>S</code>, if not specified, is set to <code>S = zeros(size(B))</code>.  For well conditioned <code>R</code>, the Schur method of [1] is used. For ill-conditioned <code>R</code> or if <code>orth = true</code>,  the generalized Schur method of [2] is used. </p><p>To enhance the accuracy of computations, a block oriented scaling of matrices <code>G</code>, <code>R</code>, <code>Q</code> and <code>S</code> is performed  using the default setting <code>scaling = &#39;B&#39;</code>. This scaling is performed only if <code>norm(Q) &gt; max(norm(G), norm(B)^2/norm(R))</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    If <code>orth = true</code>, two experimental scaling procedures  can be activated using the options <code>scaling = &#39;D&#39;</code> and <code>scaling = &#39;T&#39;</code>.  Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>.</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) eigenvalues of <code>A-BF-GX</code>.</p><p><code>F</code> is the stabilizing or anti-stabilizing gain matrix <code>F = R^(-1)(B&#39;X+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is a basis for the relevant stable/anti-stable deflating subspace  such that <code>X = Sx*(V/U)*Sxi</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively. An orthogonal basis <code>Z</code> can be determined, with an increased computational cost, by setting <code>orth = true</code>.</p><p><code>Reference:</code></p><p>[1] Laub, A.J., A Schur Method for Solving Algebraic Riccati equations.     IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.</p><p>[2] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L249-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.ared" href="#MatrixEquations.ared"><code>MatrixEquations.ared</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ared(A, B, R, Q, S; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the discrete-time algebraic Riccati equation</p><pre><code class="nohighlight hljs">A&#39;XA - X - (A&#39;XB+S)(R+B&#39;XB)^(-1)(B&#39;XA+S&#39;) + Q = 0,</code></pre><p>where <code>R</code> and <code>Q</code> are hermitian/symmetric matrices. Scalar-valued <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>R*I</code> and <code>Q*I</code>. <code>S</code>, if not specified, is set to <code>S = zeros(size(B))</code>.</p><p>To enhance the accuracy of computations, a block oriented scaling of matrices <code>R,</code> <code>Q</code> and <code>S</code> is performed  using the default setting <code>scaling = &#39;B&#39;</code>. This scaling is performed only if <code>norm(Q) &gt; norm(B)^2/norm(R)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Experimental structure preserving scalings can be performed using the options <code>scaling = &#39;D&#39;</code>, <code>scaling = &#39;R&#39;</code> and <code>scaling = &#39;T&#39;</code>.  Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable) eigenvalues of <code>A-BF</code>.</p><p><code>F</code> is the stabilizing gain matrix <code>F = (R+B&#39;XB)^(-1)(B&#39;XA+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is an orthogonal basis for the relevant stable/anti-stable deflating subspace  such that <code>X = Sx*(V/U)*Sxi</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively.</p><p><code>Reference:</code></p><p>[1] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; A = [ 0. 1.; 0. 0. ]
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  0.0

julia&gt; B = [ 0.; sqrt(2.) ]
2-element Array{Float64,1}:
 0.0
 1.4142135623730951

julia&gt; R = 1.
1.0

julia&gt; Q = [ 1. -1.; -1. 1. ]
2×2 Array{Float64,2}:
  1.0  -1.0
 -1.0   1.0

julia&gt; X, CLSEIG, F = ared(A,B,R,Q);

julia&gt; X
2×2 Array{Float64,2}:
  1.0  -1.0
 -1.0   1.5

julia&gt; A&#39;*X*A-X-A&#39;*X*B*inv(R+B&#39;*X*B)*B&#39;*X*A+Q
2×2 Array{Float64,2}:
  0.0          -3.33067e-16
 -3.33067e-16   8.88178e-16

julia&gt; CLSEIG
2-element Array{Complex{Float64},1}:
 0.4999999999999998 - 0.0im
               -0.0 - 0.0im

julia&gt; eigvals(A-B*F)
2-element Array{Float64,1}:
 -2.7755575615628914e-16
  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L785-L869">source</a></section></article><h2 id="Generalized-Riccati-Matrix-Equations"><a class="docs-heading-anchor" href="#Generalized-Riccati-Matrix-Equations">Generalized Riccati Matrix Equations</a><a id="Generalized-Riccati-Matrix-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Riccati-Matrix-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.garec" href="#MatrixEquations.garec"><code>MatrixEquations.garec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">garec(A, E, G, Q = 0; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the generalized continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs">A&#39;XE + E&#39;XA - E&#39;XGXE + Q = 0,</code></pre><p>where <code>G</code> and <code>Q</code> are hermitian/symmetric matrices or uniform scaling operators and <code>E</code> is a nonsingular matrix. Scalar-valued <code>G</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>G*I</code> and <code>Q*I</code>. The generalized Schur method of [1] is used. </p><p>To enhance the accuracy of computations, a block scaling of matrices <code>G</code> and <code>Q</code> is performed, if   the default setting <code>scaling = &#39;B&#39;</code> is used. This scaling is however performed only if <code>norm(Q) &gt; norm(G)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) generalized eigenvalues of the pair <code>(A-GXE,E)</code>.</p><p><code>Z = [U; V]</code> is an orthogonal basis for the stable/anti-stable deflating subspace such that <code>X = (Sx*(V/U)*Sxi)/E</code>,  where <code>Sx</code> and <code>Sxi</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code> and <code>scalinfo.Sxi</code>, respectively.</p><p><em>Note:</em> To solve the continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs"> A&#39;XE + E&#39;XA - E&#39;XBR^(-1)B&#39;XE + Q = 0,</code></pre><p>with <code>R</code> a hermitian/symmetric matrix and <code>B</code> a compatible size matrix, <code>G = BR^(-1)B&#39;</code> must be provided.  This approach is not numerically suited when <code>R</code> is ill-conditioned and/or <code>B</code> has large norm.  </p><p><code>Reference:</code></p><p>[1] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L411-L454">source</a></section><section><div><pre><code class="language-julia hljs">garec(A, E, B, R, Q, S; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the generalized continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs">A&#39;XE + E&#39;XA - (E&#39;XB+S)R^(-1)(B&#39;XE+S&#39;) + Q = 0,</code></pre><p>where <code>R</code> and <code>Q</code> are hermitian/symmetric matrices such that <code>R</code> is nonsingular, and <code>E</code> is a nonsingular matrix. Scalar-valued <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>R*I</code> and <code>Q*I</code>. <code>S</code>, if not specified, is set to <code>S = zeros(size(B))</code>.  The generalized Schur method of [1] is used. </p><p>To enhance the accuracy of computations, a block oriented scaling of matrices <code>R,</code> <code>Q</code> and <code>S</code> is performed  using the default setting <code>scaling = &#39;B&#39;</code>. This scaling is performed only if <code>norm(Q) &gt; norm(B)^2/norm(R)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Experimental structure preserving scalings can be performed using the options <code>scaling = &#39;D&#39;</code>  or <code>scaling = &#39;T&#39;</code>. Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) generalized eigenvalues of the pair <code>(A-BF,E)</code>.</p><p><code>F</code> is the stabilizing/anti-stabilizing gain matrix <code>F = R^(-1)(B&#39;XE+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is an orthogonal basis for the relevant stable/anti-stable deflating subspace  such that <code>X = (Sx*(V/U)*Sxi)/E</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively.</p><p><code>Reference:</code></p><p>[1] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; A = [-6. -2. 1.; 5. 1. -1; -4. -2. -1.]
3×3 Array{Float64,2}:
 -6.0  -2.0   1.0
  5.0   1.0  -1.0
 -4.0  -2.0  -1.0

julia&gt; E = [10. 3. 0.; 0. 5. -1.; 0. 0. 10.]
3×3 Array{Float64,2}:
 10.0  3.0   0.0
  0.0  5.0  -1.0
  0.0  0.0  10.0

julia&gt; B = [1. 2.; 2. 0.; 0. 1.]
3×2 Array{Float64,2}:
 1.0  2.0
 2.0  0.0
 0.0  1.0

julia&gt; R = [1. 0.; 0. 5.]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  5.0

julia&gt; X, CLSEIG, F = garec(A,E,B,R,2I);

julia&gt; X
3×3 Array{Float64,2}:
  0.0502214   0.0284089   -0.0303703
  0.0284089   0.111219    -0.00259162
 -0.0303703  -0.00259162   0.0618395

julia&gt; A&#39;*X*E+E&#39;*X*A-E&#39;*X*B*inv(R)*B&#39;*X*E+2I
3×3 Array{Float64,2}:
  1.55431e-15  -1.9984e-15   -3.33067e-15
 -1.77636e-15   1.33227e-15  -3.33067e-15
 -2.88658e-15  -3.21965e-15   1.11022e-15

julia&gt; CLSEIG
3-element Array{Complex{Float64},1}:
  -0.6184265391601464 + 0.2913286844595737im
  -0.6184265391601464 - 0.2913286844595737im
 -0.21613059964451786 + 0.0im

julia&gt; eigvals(A-B*F,E)
3-element Array{Complex{Float64},1}:
 -0.6184265391601462 - 0.29132868445957383im
 -0.6184265391601462 + 0.2913286844595739im
  -0.216130599644518 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L526-L622">source</a></section><section><div><pre><code class="language-julia hljs">garec(A, E, B, G, R, Q, S; scaling = &#39;B&#39;, pw2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the generalized continuous-time algebraic Riccati equation</p><pre><code class="nohighlight hljs">A&#39;XE + E&#39;XA - E&#39;XGXE - (E&#39;XB+S)R^(-1)(B&#39;XE+S&#39;) + Q = 0,</code></pre><p>where <code>G</code>, <code>Q</code> and <code>R</code> are hermitian/symmetric matrices such that <code>R</code> is nonsingular, and <code>E</code> is a nonsingular matrix. Scalar-valued <code>G</code>, <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>G*I</code>, <code>R*I</code> and <code>Q*I</code>. The generalized Schur method of [1] is used. </p><p>To enhance the accuracy of computations, a block oriented scaling of matrices <code>G,</code> <code>R,</code> <code>Q</code> and <code>S</code> is performed  using the default setting <code>scaling = &#39;B&#39;</code>. This scaling is performed only if <code>norm(Q) &gt; max(norm(G), norm(B)^2/norm(R))</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Experimental structure preserving scalings can be performed using the options <code>scaling = &#39;D&#39;</code>  or <code>scaling = &#39;T&#39;</code>. Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) generalized eigenvalues of the pair <code>(A-BF-GXE,E)</code>.</p><p><code>F</code> is the stabilizing/anti-stabilizing gain matrix <code>F = R^(-1)(B&#39;XE+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is an orthogonal basis for the relevant stable/anti-stable deflating subspace  such that <code>X = (Sx*(V/U)*Sxi)/E</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively.</p><p><code>Reference:</code></p><p>[1] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L628-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixEquations.gared" href="#MatrixEquations.gared"><code>MatrixEquations.gared</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gared(A, E, B, R, Q, S; scaling = &#39;B&#39;, pow2 = false, as = false, rtol::Real = nϵ, nrm = 1) -&gt; (X, EVALS, F, Z, scalinfo)</code></pre><p>Compute <code>X</code>, the hermitian/symmetric stabilizing solution (if <code>as = false</code>) or anti-stabilizing solution (if <code>as = true</code>) of the generalized discrete-time algebraic Riccati equation</p><pre><code class="nohighlight hljs">A&#39;XA - E&#39;XE - (A&#39;XB+S)(R+B&#39;XB)^(-1)(B&#39;XA+S&#39;) + Q = 0,</code></pre><p>where <code>R</code> and <code>Q</code> are hermitian/symmetric matrices, and <code>E</code> ist non-singular. Scalar-valued <code>R</code> and <code>Q</code> are interpreted as appropriately sized uniform scaling operators <code>R*I</code> and <code>Q*I</code>. <code>S</code>, if not specified, is set to <code>S = zeros(size(B))</code>.</p><p>To enhance the accuracy of computations, a block oriented scaling of matrices <code>R,</code> <code>Q</code> and <code>S</code> is performed  using the default setting <code>scaling = &#39;B&#39;</code>. This scaling is performed only if <code>norm(Q) &gt; norm(B)^2/norm(R)</code>. A general, eigenvalue computation oriented scaling combined with a block scaling is used if <code>scaling = &#39;G&#39;</code> is selected.  An alternative, structure preserving scaling can be performed using the option <code>scaling = &#39;S&#39;</code>.  A symmetric matrix equilibration based scaling is employed if <code>scaling = &#39;K&#39;</code>, for which the underlying vector norm  can be specified using the keyword argument <code>nrm = p</code>, where <code>p = 1</code> is the default setting.    Experimental structure preserving scalings can be performed using the options <code>scaling = &#39;D&#39;</code>, <code>scaling = &#39;R&#39;</code> and <code>scaling = &#39;T&#39;</code>.  Scaling can be disabled with the choice <code>scaling = &#39;N&#39;</code>. If <code>pow2 = true</code>, the scaling elements are enforced to the nearest power of 2 (default: <code>pow2 = false</code>).</p><p>By default, the lower bound for the 1-norm reciprocal condition number <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the <em>machine epsilon</em> of the element type of <code>A</code>.</p><p><code>EVALS</code> is a vector containing the (stable or anti-stable) generalized eigenvalues of the pair <code>(A-BF,E)</code>.</p><p><code>F</code> is the stabilizing/anti-stabilizing gain matrix <code>F = (R+B&#39;XB)^(-1)(B&#39;XA+S&#39;)</code>.</p><p><code>Z = [U; V; W]</code> is an orthogonal basis for the relevant stable/anti-stable deflating subspace  such that <code>X = (Sx*(V/U)*Sxi)/E</code> and  <code>F = -Sr*(W/U)*Sxi</code>,  where <code>Sx</code>, <code>Sxi</code> and <code>Sr</code> are diagonal scaling matrices contained in the named tuple <code>scalinfo</code>  as <code>scalinfo.Sx</code>, <code>scalinfo.Sxi</code> and <code>scalinfo.Sr</code>, respectively.</p><p><code>Reference:</code></p><p>[1] W.F. Arnold, III and A.J. Laub,     Generalized Eigenproblem Algorithms and Software for Algebraic Riccati Equations,     Proc. IEEE, 72:1746-1754, 1984.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; A = [-6. -2. 1.; 5. 1. -1; -4. -2. -1.]
3×3 Array{Float64,2}:
 -6.0  -2.0   1.0
  5.0   1.0  -1.0
 -4.0  -2.0  -1.0

julia&gt; E = [10. 3. 0.; 0. 5. -1.; 0. 0. 10.]
3×3 Array{Float64,2}:
 10.0  3.0   0.0
  0.0  5.0  -1.0
  0.0  0.0  10.0

julia&gt; B = [1. 2.; 2. 0.; 0. 1.]
3×2 Array{Float64,2}:
 1.0  2.0
 2.0  0.0
 0.0  1.0

julia&gt; R = [1. 0.; 0. 5.]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  5.0

julia&gt; X, CLSEIG, F = gared(A,E,B,R,2I);

julia&gt; X
3×3 Array{Float64,2}:
  0.065865   -0.0147205  -0.0100407
 -0.0147205   0.0885939   0.0101422
 -0.0100407   0.0101422   0.0234425

julia&gt; A&#39;*X*A-E&#39;*X*E-A&#39;*X*B*inv(R+B&#39;*X*B)*B&#39;*X*A+2I
3×3 Array{Float64,2}:
 -1.33227e-15  -2.48412e-15   1.38778e-16
 -2.498e-15    -4.44089e-16  -6.50521e-16
  1.80411e-16  -5.91541e-16  -1.33227e-15

julia&gt; CLSEIG
3-element Array{Complex{Float64},1}:
  -0.084235615751339 - 0.0im
  -0.190533552034239 - 0.0im
 -0.5238922629921539 - 0.0im

julia&gt; eigvals(A-B*F,E)
3-element Array{Float64,1}:
 -0.5238922629921539
 -0.19053355203423886
 -0.08423561575133902</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixEquations.jl/blob/28bf8ec9bcb0328b2345300ae0f5aa6d97292324/src/riccati.jl#L875-L969">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="plyapunov.html">« Positive-definite Lyapunov Matrix Equation Solvers</a><a class="docs-footer-nextpage" href="sylvester.html">Sylvester Matrix Equation Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Wednesday 26 March 2025 11:24">Wednesday 26 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
